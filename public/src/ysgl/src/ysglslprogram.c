#include "ysgldef.h"
#include "ysglslprogram.h"
const char *YSGLSL_variColor3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	{\n",
	"		LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		// Who said if-statement should be avoided?\n",
	"		// Sampling twice seems to cost a lot more than a if-statement in ThinkPad X250 and 2014 Mac mini.\n",
	"		if(0.0<textureSampleCoeff[1]+textureSampleCoeff[2])\n",
	"		{\n",
	"			texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"			texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0]+texcell[1]*textureSampleCoeff[1]+texcell[2]*textureSampleCoeff[2])\n",
	"			   +vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0])+vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColor3DDrawingFragmentShader_nLine=117;
const char *YSGLSL_variColor3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP   float pointSizeIn;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP   vec4 colorIn;\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"	gl_PointSize=pointSizeIn;\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColor3DDrawingVertexShader_nLine=151;
const char *YSGLSL_variColorPerVtxShading3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	gl_FragColor=colorOut;\n",
	"\n",
	"	{\n",
	"		LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		// Who said if-statement should be avoided?\n",
	"		// Sampling twice seems to cost a lot more than a if-statement in ThinkPad X250 and 2014 Mac mini.\n",
	"		if(0.0<textureSampleCoeff[1]+textureSampleCoeff[2])\n",
	"		{\n",
	"			texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"			texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0]+texcell[1]*textureSampleCoeff[1]+texcell[2]*textureSampleCoeff[2])\n",
	"			   +vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0])+vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerVtxShading3DDrawingFragmentShader_nLine=117;
const char *YSGLSL_variColorPerVtxShading3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 projection;\n",
	"uniform  HIGHP mat4 modelView;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  HIGHP  vec3 normal;\n",
	"attribute  LOWP   vec4 color;    // <- Only difference from monoColorPerVtxShader\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"uniform MIDP float lightEnabled[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform HIGHP vec4 lightPos[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform LOWP vec3 lightColor[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform LOWP vec3 specularColor;\n",
	"uniform MIDP float specularExponent;\n",
	"uniform LOWP vec3 ambientColor;\n",
	"\n",
	"// Lighting\n",
	"//	Input variables: vec4 color\n",
	"//	                 vec3 nomLocal\n",
	"//	                 vec3 vecToCamera <- must be normalized\n",
	"//	Output variable: vec4 accumColor\n",
	"\n",
	"// lightCoeff can be used for cutting off diffuse and specular reflection for dealing with shadow.\n",
	"// lightCoeff can be between 0 and 1.\n",
	"LOWP vec4 YsCalculateStandardLighting(\n",
	"    in LOWP vec4 color,in HIGHP vec3 nomLocal,in HIGHP vec3 vecToCamera,in MIDP float lightCoeff)\n",
	"{\n",
	"	LOWP vec3 accumColor=ambientColor*color.xyz;\n",
	"\n",
	"	for(int lightNo=0; lightNo<YSGLSL_MAX_NUM_LIGHT; lightNo++)\n",
	"	{\n",
	"		MIDP float diffuseIntensity=lightCoeff*max(dot(nomLocal,lightPos[lightNo].xyz),0.0);\n",
	"		HIGHP vec3 unitVecToCamera=normalize(vecToCamera);\n",
	"		HIGHP vec3 mid=normalize(lightPos[lightNo].xyz+unitVecToCamera);\n",
	"		HIGHP float specularIntensity=lightCoeff*pow(max(dot(mid,nomLocal),0.0),specularExponent);\n",
	"\n",
	"		accumColor+=lightEnabled[lightNo]*diffuseIntensity*(color.xyz*lightColor[lightNo]);\n",
	"		accumColor+=lightEnabled[lightNo]*specularIntensity*specularColor;\n",
	"	}\n",
	"\n",
	"	return vec4(accumColor,color[3]);\n",
	"}\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	HIGHP vec3 nomLocal=normalize((modelView*vec4(normal,0)).xyz);\n",
	"	HIGHP vec3 vecToCamera=-normalize(vertexInView.xyz);\n",
	"\n",
	"	colorOut=YsCalculateStandardLighting(color,nomLocal,vecToCamera,1.0);\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerVtxShading3DDrawingVertexShader_nLine=187;
const char *YSGLSL_variColorPerPixShading3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 projection;\n",
	"uniform  HIGHP mat4 modelView;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  HIGHP  vec3 normal;\n",
	"attribute  LOWP   vec4 colorIn;\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  HIGHP  vec3 normalOut;\n",
	"varying  HIGHP  vec3 vecToCameraOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"uniform MIDP float useShadowMap[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float useShadowTest[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform HIGHP mat4 shadowMapTransform[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform sampler2D shadowMapTexture[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float lightDistScale[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float lightDistOffset[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"\n",
	"varying HIGHP vec3 shadowCoord[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	HIGHP vec4 normal4d=vec4(normal,0);\n",
	"	normalOut=normalize((modelView*normal4d).xyz);\n",
	"	vecToCameraOut=-normalize(vertexInView.xyz);\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"\n",
	"	// Shadow Map >>\n",
	"	for(int i=0; i<YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE; ++i)\n",
	"	{\n",
	"		vec4 inShadowPos=shadowMapTransform[i]*vertexInView;\n",
	"		shadowCoord[i]=(vec3(1,1,1)+(inShadowPos.xyz/inShadowPos.w))/2.0;\n",
	"		shadowCoord[i].z/=lightDistScale[i];\n",
	"		shadowCoord[i].z-=lightDistOffset[i];\n",
	"	}\n",
	"	// Shadow Map <<\n",
	"\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerPixShading3DDrawingVertexShader_nLine=179;
const char *YSGLSL_variColorPerPixShading3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 modelView;\n",
	"\n",
	"varying  HIGHP  vec3 normalOut;\n",
	"varying  HIGHP  vec3 vecToCameraOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"\n",
	"LOWP vec4 YsGLSLRainbowColor(HIGHP float t)\n",
	"{\n",
	"	// 0     0.25  0.5    0.75    1\n",
	"	// Blue->Cyan->Green->Yellow->Red\n",
	"\n",
	"	HIGHP float tt=t*4.0;\n",
	"	LOWP  float blue =clamp(2.0-tt         ,0.0,1.0);\n",
	"	LOWP  float green=clamp(2.0-abs(tt-2.0),0.0,1.0);\n",
	"	LOWP  float red  =clamp(tt-2.0         ,0.0,1.0);\n",
	"	return vec4(red,green,blue,1.0);\n",
	"\n",
	"	// HIGHP float tt;\n",
	"	// if(t<0.0)\n",
	"	// {\n",
	"	// 	return vec4(0,0,1,1);\n",
	"	// }\n",
	"	// else if(t<0.25)\n",
	"	// {\n",
	"	// 	tt=t/0.25;\n",
	"	// 	return vec4(0,tt,1,1);\n",
	"	// }\n",
	"	// else if(t<0.5)\n",
	"	// {\n",
	"	// 	tt=(t-0.25)/0.25;\n",
	"	// 	return vec4(0,1,1.0-tt,1);\n",
	"	// }\n",
	"	// else if(t<0.75)\n",
	"	// {\n",
	"	// 	tt=(t-0.5)/0.25;\n",
	"	// 	return vec4(tt,1,0,1);\n",
	"	// }\n",
	"	// else if(t<1.0)\n",
	"	// {\n",
	"	// 	tt=(t-0.75)/0.25;\n",
	"	// 	return vec4(1,1.0-tt,0,1);\n",
	"	// }\n",
	"	// else\n",
	"	// {\n",
	"	// 	return vec4(1,0,0,1);\n",
	"	// }\n",
	"}\n",
	"\n",
	"MIDP float YsIsInRange(HIGHP float min,HIGHP float max,HIGHP float x)\n",
	"{\n",
	"	return step(min,x)*step(x,max);\n",
	"}\n",
	"\n",
	"MIDP float YsIsInRange(HIGHP float min,HIGHP float max,HIGHP vec2 v)\n",
	"{\n",
	"	return step(min,v.x)*step(v.x,max)\n",
	"          *step(min,v.y)*step(v.y,max);\n",
	"}\n",
	"\n",
	"MIDP float YsIsInRange(HIGHP float min,HIGHP float max,HIGHP vec3 v)\n",
	"{\n",
	"	return step(min,v.x)*step(v.x,max)\n",
	"          *step(min,v.y)*step(v.y,max)\n",
	"          *step(min,v.z)*step(v.z,max);\n",
	"}\n",
	"\n",
	"\n",
	"// Variables for texturing\n",
	"uniform LOWP  int   textureType;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  vec3  textureSampleCoeff;\n",
	"\n",
	"uniform LOWP  mat4 textureTileTransform;\n",
	"uniform LOWP  int  billBoardTransformType;\n",
	"uniform       bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform HIGHP vec3 billBoardCenter;\n",
	"uniform HIGHP vec2 billBoardDimension;\n",
	"uniform sampler2D  textureIdent;\n",
	"varying HIGHP vec3 texCoordOut;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"uniform MIDP float useShadowMap[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float useShadowTest[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform HIGHP mat4 shadowMapTransform[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform sampler2D shadowMapTexture[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float lightDistScale[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"uniform MIDP float lightDistOffset[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"\n",
	"varying HIGHP vec3 shadowCoord[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"\n",
	"\n",
	"uniform MIDP float lightEnabled[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform HIGHP vec4 lightPos[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform LOWP vec3 lightColor[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform LOWP vec3 specularColor;\n",
	"uniform MIDP float specularExponent;\n",
	"uniform LOWP vec3 ambientColor;\n",
	"\n",
	"// Lighting\n",
	"//	Input variables: vec4 color\n",
	"//	                 vec3 nomLocal\n",
	"//	                 vec3 vecToCamera <- must be normalized\n",
	"//	Output variable: vec4 accumColor\n",
	"\n",
	"// lightCoeff can be used for cutting off diffuse and specular reflection for dealing with shadow.\n",
	"// lightCoeff can be between 0 and 1.\n",
	"LOWP vec4 YsCalculateStandardLighting(\n",
	"    in LOWP vec4 color,in HIGHP vec3 nomLocal,in HIGHP vec3 vecToCamera,in MIDP float lightCoeff)\n",
	"{\n",
	"	LOWP vec3 accumColor=ambientColor*color.xyz;\n",
	"\n",
	"	for(int lightNo=0; lightNo<YSGLSL_MAX_NUM_LIGHT; lightNo++)\n",
	"	{\n",
	"		MIDP float diffuseIntensity=lightCoeff*max(dot(nomLocal,lightPos[lightNo].xyz),0.0);\n",
	"		HIGHP vec3 unitVecToCamera=normalize(vecToCamera);\n",
	"		HIGHP vec3 mid=normalize(lightPos[lightNo].xyz+unitVecToCamera);\n",
	"		HIGHP float specularIntensity=lightCoeff*pow(max(dot(mid,nomLocal),0.0),specularExponent);\n",
	"\n",
	"		accumColor+=lightEnabled[lightNo]*diffuseIntensity*(color.xyz*lightColor[lightNo]);\n",
	"		accumColor+=lightEnabled[lightNo]*specularIntensity*specularColor;\n",
	"	}\n",
	"\n",
	"	return vec4(accumColor,color[3]);\n",
	"}\n",
	"\n",
	"\n",
	"// #define ENABLE_SHADOW_TEST\n",
	"\n",
	"void main()\n",
	"{\n",
	"	HIGHP vec3 nomLocal=normalize(normalOut);\n",
	"	HIGHP vec3 vecToCamera=normalize(vecToCameraOut);\n",
	"\n",
	"	MIDP  float inVolume[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"	inVolume[0]=YsIsInRange(0.001,0.999,shadowCoord[0]);\n",
	"	inVolume[1]=YsIsInRange(0.001,0.999,shadowCoord[1])*(1.0-inVolume[0]);\n",
	"#if 3<=YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE\n",
	"	inVolume[2]=YsIsInRange(0.001,0.999,shadowCoord[2])*(1.0-inVolume[0])*(1.0-inVolume[1]);\n",
	"#endif\n",
	"\n",
	"	// useShadowMap==0 || inVolume==0.0 -> inShadow=0.0\n",
	"	// useShadowMap==1 && inVolume==1.0 -> inShadow=step(shadowDepth,shadowCoordTfm.z);\n",
	"	MIDP  float inShadow[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"#ifdef ENABLE_SHADOW_TEST\n",
	"	LOWP  vec4 shadowTestColor[YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE];\n",
	"#endif\n",
	"	for(int i=0; i<YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE; ++i)\n",
	"	{\n",
	"		inShadow[i]=0.0;\n",
	"\n",
	"		// This if-statement improved the frame rate from 38+ to 55+ in ThinkPad X250.\n",
	"		// I have a serious doubt about the suggestion that if-statement should be avoided all together in fragment shaders.\n",
	"		if(0.999<inVolume[i])\n",
	"		{\n",
	"			HIGHP float shadowDepth=texture2D(shadowMapTexture[i],shadowCoord[i].xy).r;\n",
	"			inShadow[i]=useShadowMap[i]*inVolume[i]*step(shadowDepth,shadowCoord[i].z);\n",
	"		#ifdef ENABLE_SHADOW_TEST\n",
	"			shadowTestColor[i]=inVolume[i]*YsGLSLRainbowColor(shadowDepth)+vec4(1,0,1,1)*(1.0-inVolume[i]);\n",
	"		#endif\n",
	"		}\n",
	"	}\n",
	"\n",
	"	// If either one of inShadow0 or inShadow1 is 1, specular and diffuse must be off (lightCoeff=0)\n",
	"#if 3<=YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE\n",
	"	MIDP  float lightCoeff=(1.0-inShadow[0])*(1.0-inShadow[1])*(1.0-inShadow[2]);\n",
	"#elif 2<=YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE\n",
	"	MIDP  float lightCoeff=(1.0-inShadow[0])*(1.0-inShadow[1]);\n",
	"#endif\n",
	"\n",
	"	LOWP  vec4 accumColor=YsCalculateStandardLighting(color,nomLocal,vecToCamera,lightCoeff);\n",
	"\n",
	"\n",
	"#ifdef ENABLE_SHADOW_TEST\n",
	"	// Shadow Map Test >>\n",
	"#if 3<=YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE\n",
	"	accumColor=accumColor*(1.0-inVolume[0]*useShadowTest[0])*(1.0-inVolume[1]*useShadowTest[1])*(1.0-inVolume[2]*useShadowTest[2])\n",
	"	           +shadowTestColor[0]*inVolume[0]*useShadowTest[0]\n",
	"	           +shadowTestColor[1]*inVolume[1]*useShadowTest[1]\n",
	"	           +shadowTestColor[2]*inVolume[2]*useShadowTest[2];\n",
	"#else\n",
	"	accumColor=accumColor*(1.0-inVolume[0]*useShadowTest[0])*(1.0-inVolume[1]*useShadowTest[1])\n",
	"	           +shadowTestColor[0]*inVolume[0]*useShadowTest[0]\n",
	"	           +shadowTestColor[1]*inVolume[1]*useShadowTest[1];\n",
	"#endif\n",
	"	// 2016/10/20 Looks like if I modify gl_FragColor in this timing, the whole thing blows up. (In Windows driver, Intel GPU only, seems to be)\n",
	"	// Shadow Map Test  <<\n",
	"#endif\n",
	"\n",
	"	gl_FragColor=accumColor;\n",
	"\n",
	"	{\n",
	"		LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		// Who said if-statement should be avoided?\n",
	"		// Sampling twice seems to cost a lot more than a if-statement in ThinkPad X250 and 2014 Mac mini.\n",
	"		if(0.0<textureSampleCoeff[1]+textureSampleCoeff[2])\n",
	"		{\n",
	"			texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"			texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0]+texcell[1]*textureSampleCoeff[1]+texcell[2]*textureSampleCoeff[2])\n",
	"			   +vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			avg=useTexture*(texcell[0]*textureSampleCoeff[0])+vec4(1.0-useTexture,1.0-useTexture,1.0-useTexture,1.0-useTexture);\n",
	"		}\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerPixShading3DDrawingFragmentShader_nLine=288;
const char *YSGLSL_variColorBillBoard3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform LOWP  float usePointClippingCircle;\n",
	"\n",
	"uniform LOWP int billBoardTransformType;\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"varying  HIGHP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP  vec2 nomLocal=(texCoordOut.xy*2.0)-vec2(1.0,1.0);\n",
	"	if(1.0<=usePointClippingCircle*dot(nomLocal,nomLocal))\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	 LOWP  vec4 texcell=texture2D(textureIdent,texCoordOut);\n",
	"	gl_FragColor=color*texcell;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorBillBoard3DDrawingFragmentShader_nLine=98;
const char *YSGLSL_variColorBillBoard3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform LOWP int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  MIDP  vec3 viewOffset;\n",
	"attribute  MIDP  vec2 texCoord;\n",
	"\n",
	"varying  HIGHP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"	{\n",
	"		vertexInView.xyz+=viewOffset;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		vec3 axis[3];\n",
	"		 MIDP  vec3 viewVec=normalize(vertexInView.xyz);\n",
	"		 MIDP  float pitch=asin(viewVec.y);\n",
	"		 MIDP  float heading=-asin(viewVec.x);\n",
	"		axis[0]=vec3(cos(heading),0.0,-sin(heading));\n",
	"		axis[1]=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"		axis[2]=-viewVec;\n",
	"		vertexInView.xyz+=(axis[0]*viewOffset[0]+axis[1]*viewOffset[1]+axis[2]*viewOffset[2]);\n",
	"	}\n",
	"	texCoordOut=texCoord;\n",
	"	if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"	{\n",
	"		texCoordOut=(texCoordOut+vec2(1.0,1.0))/vec2(2.0,2.0);\n",
	"	}\n",
	"	color=colorIn;\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorBillBoard3DDrawingVertexShader_nLine=110;
const char *YSGLSL_flash3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"varying  LOWP  vec2 uv;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// No alpha cut off in the flash renderer.\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	const  MIDP  float PI=3.1415927;\n",
	"	const  MIDP  float halfPI=3.1415927/2.0;\n",
	"	const  MIDP  float twoPI=3.1415927*2.0;\n",
	"	 MIDP  float r=length(uv);\n",
	"	if(r<=radius1)\n",
	"	{\n",
	"		 MIDP  float param=halfPI*(radius1-r)/radius1;\n",
	"		 MIDP  float additive=sin(param)*maxIntensity;\n",
	"		gl_FragColor[0]=min(1.0,color[0]+additive);\n",
	"		gl_FragColor[1]=min(1.0,color[1]+additive);\n",
	"		gl_FragColor[2]=min(1.0,color[2]+additive);\n",
	"		gl_FragColor[3]=color[3];\n",
	"\n",
	"		// f  0:Completely fogged out   1:Clear\n",
	"		// f=e^(-d*d)\n",
	"		// d  0:Clear      Infinity: Completely fogged out\n",
	"		// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"		// -d*d=loge(0.01)\n",
	"		// -d*d= -4.60517\n",
	"		// d=2.146\n",
	"		// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"		{\n",
	"			MIDP  float d=fogDensity*abs(fogZ);\n",
	"			MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"			LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"			gl_FragColor.rgb=fogMix;\n",
	"		}\n",
	"\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		 MIDP  float halfInterval=angleInterval/2.0;\n",
	"		 MIDP  float theata=twoPI+angleOffset+atan(uv.y,uv.x);\n",
	"		 MIDP  float t=mod(theata,angleInterval);\n",
	"		 MIDP  float s=1.0-abs(t-halfInterval)/halfInterval;\n",
	"\n",
	"		 MIDP  float rf=radius1+(radius2-radius1)*pow(s,exponent);\n",
	"		if(rf<r)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 MIDP  float alpha=max(1.0-(r-radius1)/(rf-radius1),0.0);\n",
	"			gl_FragColor[0]=color[0];\n",
	"			gl_FragColor[1]=color[1];\n",
	"			gl_FragColor[2]=color[2];\n",
	"			gl_FragColor[3]=color[3]*alpha;\n",
	"\n",
	"			// f  0:Completely fogged out   1:Clear\n",
	"			// f=e^(-d*d)\n",
	"			// d  0:Clear      Infinity: Completely fogged out\n",
	"			// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"			// -d*d=loge(0.01)\n",
	"			// -d*d= -4.60517\n",
	"			// d=2.146\n",
	"			// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"			{\n",
	"				MIDP  float d=fogDensity*abs(fogZ);\n",
	"				MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"				LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"				gl_FragColor.rgb=fogMix;\n",
	"			}\n",
	"\n",
	"		}\n",
	"    }\n",
	"}\n",
};
const int YSGLSL_flash3DDrawingFragmentShader_nLine=135;
const char *YSGLSL_flash3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float dimension;\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  HIGHP  vec3 viewOffset;\n",
	"\n",
	"varying  LOWP  vec2 uv;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	vec3 offset=viewOffset*dimension;\n",
	"	vertexInView.x+=offset.x;\n",
	"	vertexInView.y+=offset.y;\n",
	"	vertexInView.z+=offset.z;\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	uv=vec2(viewOffset.x,viewOffset.y);\n",
	"	color=colorIn;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_flash3DDrawingVertexShader_nLine=100;
const char *YSGLSL_flashByPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// No alpha cut off in the flash renderer.\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP vec2 uv=((gl_PointCoord.xy*2.0)-vec2(1.0,1.0));\n",
	"\n",
	"	const  MIDP  float PI=3.1415927;\n",
	"	const  MIDP  float halfPI=3.1415927/2.0;\n",
	"	const  MIDP  float twoPI=3.1415927*2.0;\n",
	"	 MIDP  float r=length(uv);\n",
	"	if(r<=radius1)\n",
	"	{\n",
	"		 MIDP  float param=halfPI*(radius1-r)/radius1;\n",
	"		 MIDP  float additive=sin(param)*maxIntensity;\n",
	"		gl_FragColor[0]=min(1.0,color[0]+additive);\n",
	"		gl_FragColor[1]=min(1.0,color[1]+additive);\n",
	"		gl_FragColor[2]=min(1.0,color[2]+additive);\n",
	"		gl_FragColor[3]=color[3];\n",
	"\n",
	"		// f  0:Completely fogged out   1:Clear\n",
	"		// f=e^(-d*d)\n",
	"		// d  0:Clear      Infinity: Completely fogged out\n",
	"		// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"		// -d*d=loge(0.01)\n",
	"		// -d*d= -4.60517\n",
	"		// d=2.146\n",
	"		// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"		{\n",
	"			MIDP  float d=fogDensity*abs(fogZ);\n",
	"			MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"			LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"			gl_FragColor.rgb=fogMix;\n",
	"		}\n",
	"\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		 MIDP  float halfInterval=angleInterval/2.0;\n",
	"		 MIDP  float theata=twoPI+angleOffset+atan(uv.y,uv.x);\n",
	"		 MIDP  float t=mod(theata,angleInterval);\n",
	"		 MIDP  float s=1.0-abs(t-halfInterval)/halfInterval;\n",
	"\n",
	"		 MIDP  float rf=radius1+(radius2-radius1)*pow(s,exponent);\n",
	"		if(rf<r)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			MIDP  float alpha=max(1.0-(r-radius1)/(rf-radius1),0.0);\n",
	"			gl_FragColor[0]=color[0];\n",
	"			gl_FragColor[1]=color[1];\n",
	"			gl_FragColor[2]=color[2];\n",
	"			gl_FragColor[3]=color[3]*alpha;\n",
	"\n",
	"			// f  0:Completely fogged out   1:Clear\n",
	"			// f=e^(-d*d)\n",
	"			// d  0:Clear      Infinity: Completely fogged out\n",
	"			// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"			// -d*d=loge(0.01)\n",
	"			// -d*d= -4.60517\n",
	"			// d=2.146\n",
	"			// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"			{\n",
	"				MIDP  float d=fogDensity*abs(fogZ);\n",
	"				MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"				LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"				gl_FragColor.rgb=fogMix;\n",
	"			}\n",
	"\n",
	"		}\n",
	"    }\n",
	"}\n",
};
const int YSGLSL_flashByPointSprite3DDrawingFragmentShader_nLine=136;
const char *YSGLSL_flashByPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"\n",
	"attribute  HIGHP vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  MIDP  float pointSizeIn;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform LOWP  float usePointSizeInPixel;\n",
	"uniform LOWP  float usePointSizeIn3D;\n",
	"uniform LOWP  float usePointClippingCircle;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void Ys_ProcessPointSprite()\n",
	"{\n",
	"	HIGHP vec4 prj1=projection*modelView*vec4(vertex,1.0);\n",
	"	HIGHP vec4 prj2=modelView*vec4(vertex,1.0);\n",
	"	prj2.y+=pointSizeIn;\n",
	"	prj2=projection*prj2;\n",
	"\n",
	"	HIGHP float pointSize3D=viewportHei*abs(prj2[1]/prj2[3]-prj1[1]/prj1[3])/2.0;\n",
	"\n",
	"	gl_PointSize=pointSizeIn*usePointSizeInPixel+pointSize3D*usePointSizeIn3D;\n",
	"}\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	Ys_ProcessPointSprite();\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_flashByPointSprite3DDrawingVertexShader_nLine=117;
const char *YSGLSL_variColorMarker3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform LOWP int markerType;\n",
	"uniform  MIDP  float dimension;\n",
	"\n",
	"varying  MIDP  vec2 offsetOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	if(markerType==YSGLSL_MARKER_TYPE_RECT)\n",
	"	{\n",
	"		if(dimension<abs(offsetOut.x) || dimension<abs(offsetOut.y))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_CIRCLE)\n",
	"	{\n",
	"		if(dimension*dimension<offsetOut.x*offsetOut.x+offsetOut.y*offsetOut.y)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_RECT)\n",
	"	{\n",
	"		if( dimension    <abs(offsetOut.x) || dimension    <abs(offsetOut.y) ||\n",
	"		   (dimension-1.2>abs(offsetOut.x) && dimension-1.2>abs(offsetOut.y)))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_CIRCLE)\n",
	"	{\n",
	"		 MIDP  float offsetSq=offsetOut.x*offsetOut.x+offsetOut.y*offsetOut.y;\n",
	"		if( dimension*dimension           <offsetSq ||\n",
	"		   (dimension-1.2)*(dimension-1.2)>offsetSq)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_STAR)\n",
	"	{\n",
	"		// See star.png for the equations.\n",
	"		bool show=false;\n",
	"		MIDP  float  x=offsetOut.x/dimension;\n",
	"		MIDP  float  y=offsetOut.y/dimension;\n",
	"		MIDP  float  x3_077685=3.0077685*x;\n",
	"		MIDP  float  yMinus1=y-1.0;\n",
	"		if(y<=0.309017)\n",
	"		{\n",
	"			MIDP  float  x0_726543=0.726543*x;\n",
	"			MIDP  float  yPlus0_381966=y+0.381966;\n",
	"			if((yPlus0_381966>= x0_726543 && yMinus1<= x3_077685) ||\n",
	"			   (yPlus0_381966>=-x0_726543 && yMinus1<=-x3_077685))\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			if(yMinus1<=x3_077685 && yMinus1<=-x3_077685)\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_STAR)\n",
	"	{\n",
	"		bool show=false;\n",
	"		MIDP  float  x=offsetOut.x/dimension;\n",
	"		MIDP  float  y=offsetOut.y/dimension;\n",
	"		MIDP  float  q1=-3.077685*x+1.0;\n",
	"		MIDP  float  q2= 3.077685*x+1.0;\n",
	"		MIDP  float  q3= 0.726543*x-0.381966;\n",
	"		MIDP  float  q4=-0.726543*x-0.381966;\n",
	"		if(y>=0.309017 && y<=q1 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q1 && y>=q3)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q2 && y>=q4)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q3 && y>=q4 && y<=q1)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q4 && y>=q3 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorMarker3DDrawingFragmentShader_nLine=184;
const char *YSGLSL_variColorMarker3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"\n",
	"uniform LOWP int markerType;\n",
	"uniform  MIDP  float dimension;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  MIDP  vec2 pixelOffset;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"\n",
	"varying  MIDP  vec2 offsetOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"	float xOffset=((2.0*pixelOffset.x)/viewportWid)*gl_Position[3];\n",
	"	float yOffset=((2.0*pixelOffset.y)/viewportHei)*gl_Position[3];\n",
	"	gl_Position.x+=xOffset;\n",
	"	gl_Position.y+=yOffset;\n",
	"	offsetOut=pixelOffset;\n",
	"	color=colorIn;\n",
	"}\n",
};
const int YSGLSL_variColorMarker3DDrawingVertexShader_nLine=93;
const char *YSGLSL_variColorMarkerByPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"\n",
	"uniform LOWP int markerType;\n",
	"uniform MIDP float dimension;\n",
	"\n",
	"varying LOWP vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP vec2 t=(gl_PointCoord.xy*2.0)-vec2(1.0,1.0);\n",
	"	t.y=-t.y;\n",
	"\n",
	"	if(markerType==YSGLSL_MARKER_TYPE_RECT)\n",
	"	{\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_CIRCLE)\n",
	"	{\n",
	"		if(1.0<dot(t,t))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_RECT)\n",
	"	{\n",
	"		MIDP float frameSize=2.4/dimension; // 1pixel=2.0/dimension   1.2pixel=2.4/dimension\n",
	"		if(abs(t.x)<1.0-frameSize && abs(t.y)<1.0-frameSize)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_CIRCLE)\n",
	"	{\n",
	"		MIDP float frameSize=2.4/dimension; // 1pixel=2.0/dimension   1.2pixel=2.4/dimension\n",
	"		MIDP float tsq=dot(t,t);\n",
	"		MIDP float inRad=1.0-frameSize;\n",
	"		if(tsq<inRad*inRad || 1.0<tsq)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_STAR)\n",
	"	{\n",
	"		// See star.png for the equations.\n",
	"		bool show=false;\n",
	"		MIDP  float  x=t.x;\n",
	"		MIDP  float  y=t.y;\n",
	"		MIDP  float  x3_077685=3.0077685*x;\n",
	"		MIDP  float  yMinus1=y-1.0;\n",
	"		if(y<=0.309017)\n",
	"		{\n",
	"			MIDP float x0_726543=0.726543*x;\n",
	"			MIDP float yPlus0_381966=y+0.381966;\n",
	"			if((yPlus0_381966>= x0_726543 && yMinus1<= x3_077685) ||\n",
	"			   (yPlus0_381966>=-x0_726543 && yMinus1<=-x3_077685))\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			if(yMinus1<=x3_077685 && yMinus1<=-x3_077685)\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_STAR)\n",
	"	{\n",
	"		bool show=false;\n",
	"		MIDP  float  x=t.x;\n",
	"		MIDP  float  y=t.y;\n",
	"		MIDP  float  q1=-3.077685*x+1.0;\n",
	"		MIDP  float  q2= 3.077685*x+1.0;\n",
	"		MIDP  float  q3= 0.726543*x-0.381966;\n",
	"		MIDP  float  q4=-0.726543*x-0.381966;\n",
	"		if(y>=0.309017 && y<=q1 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q1 && y>=q3)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q2 && y>=q4)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q3 && y>=q4 && y<=q1)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q4 && y>=q3 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorMarkerByPointSprite3DDrawingFragmentShader_nLine=186;
const char *YSGLSL_variColorMarkerByPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"\n",
	"uniform LOWP int markerType;\n",
	"uniform MIDP float dimension;\n",
	"\n",
	"attribute HIGHP vec3 vertex;\n",
	"attribute LOWP vec4 colorIn;\n",
	"\n",
	"varying LOWP vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"	gl_PointSize=dimension;\n",
	"}\n",
};
const int YSGLSL_variColorMarkerByPointSprite3DDrawingVertexShader_nLine=88;
const char *YSGLSL_bmpRendererVertexShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"// offset is taken as pixels if transformationType is true, or size in 3D space.\n",
	"// transformationType:\n",
	"//    0: Attributes vertex and offset are both taken as in 3D coordinate.\n",
	"//    1: Attributes vertex and offset are both taken as in window coordinate.\n",
	"//    2: Attribute vertex is taken as in 3D coordinate, and offset is taken as in window coordinate\n",
	"uniform  HIGHP  mat4 projection,modelView;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"uniform sampler2D texture;\n",
	"uniform int transformationType;\n",
	"uniform int viewportOrigin;\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"attribute  HIGHP  vec4 vertex;\n",
	"attribute  MIDP  vec2 offset;\n",
	"attribute  MIDP vec2 texCoord;\n",
	"\n",
	"varying  MIDP  vec2 texCoord_out;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	texCoord_out=texCoord;\n",
	"	if(1==transformationType)\n",
	"	{\n",
	"		float xOffset=(2.0*offset.x)/viewportWid;\n",
	"		float yOffset=(2.0*offset.y)/viewportHei;\n",
	"\n",
	"		float xAbs=-1.0+2.0*vertex.x/viewportWid+xOffset;\n",
	"		float yAbs= 1.0-2.0*vertex.y/viewportHei;\n",
	"		if(0!=viewportOrigin)\n",
	"		{\n",
	"			yAbs=-yAbs;\n",
	"		}\n",
	"		yAbs+=yOffset;\n",
	"		gl_Position=vec4(xAbs,yAbs,0.0,1.0);\n",
	"	}\n",
	"	else if(0==transformationType)\n",
	"	{\n",
	"		vec4 inCameraCoord=modelView*vertex+vec4(offset.x,offset.y,0,0);\n",
	"		gl_Position=projection*inCameraCoord;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		float xOffset=(2.0*offset.x)/viewportWid;\n",
	"		float yOffset=(2.0*offset.y)/viewportHei;\n",
	"		gl_Position=projection*modelView*vertex;\n",
	"		gl_Position.x+=xOffset;\n",
	"		gl_Position.y+=yOffset;\n",
	"	}\n",
	"}\n",
};
const int YSGLSL_bmpRendererVertexShaderSrc_nLine=97;
const char *YSGLSL_bmpRendererFragmentShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform sampler2D texture;\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"varying  MIDP  vec2 texCoord_out;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 LOWP  vec4 texcell=texture2D(texture,texCoord_out);\n",
	"	if(alphaCutOff<texcell.a)\n",
	"	{\n",
	"		gl_FragColor=texcell;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"}\n",
};
const int YSGLSL_bmpRendererFragmentShaderSrc_nLine=65;
const char *YSGLSL_plain2DDrawingVertexShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform HIGHP  mat4 transform;\n",
	"\n",
	"attribute LOWP vec2 vertex;\n",
	"attribute MIDP vec2 texCoordIn;\n",
	"attribute LOWP vec4 colorIn;\n",
	"attribute MIDP float pointSizeIn;\n",
	"\n",
	"varying LOWP  vec4 colorOut;\n",
	"varying MIDP  vec2 texCoordOut;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	vec4 vertex4d=vec4(vertex,0,1);\n",
	"	gl_Position=transform*vertex4d;\n",
	"	colorOut=colorIn;\n",
	"	texCoordOut=texCoordIn;\n",
	"	gl_PointSize=pointSizeIn;\n",
	"}\n",
};
const int YSGLSL_plain2DDrawingVertexShaderSrc_nLine=66;
const char *YSGLSL_plain2DDrawingFragmentShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform HIGHP mat4 transform;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform       sampler2D textureIdent;\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"varying MIDP  vec2 texCoordOut;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	LOWP  vec4 avg;\n",
	"	avg=texture2D(textureIdent,texCoordOut.xy)*useTexture+vec4(1.0,1.0,1.0,1.0)*(1.0-useTexture);\n",
	"	gl_FragColor=colorOut*avg;\n",
	"}\n",
};
const int YSGLSL_plain2DDrawingFragmentShaderSrc_nLine=61;
const char *YSGLSL_variColorPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"varying  MIDP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform LOWP  float usePointSizeInPixel;\n",
	"uniform LOWP  float usePointSizeIn3D;\n",
	"uniform LOWP  float usePointClippingCircle;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP  vec2 t=(gl_PointCoord.xy*2.0)-vec2(1.0,1.0);\n",
	"	if(1.0<=usePointClippingCircle*dot(t,t))\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	MIDP  vec2 texCoord=texCoordOut+gl_PointCoord*texCoordRange;\n",
	"	LOWP  vec4 texcell=texture2D(textureIdent,texCoord);\n",
	"	gl_FragColor=useTexture*color*texcell+(1.0-useTexture)*color;\n",
	"\n",
	"	// gl_FragColor.rg=gl_PointCoord;  For debugging.\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	// f  0:Completely fogged out   1:Clear\n",
	"	// f=e^(-d*d)\n",
	"	// d  0:Clear      Infinity: Completely fogged out\n",
	"	// 99% fogged out means:  e^(-d*d)=0.01  What's d?\n",
	"	// -d*d=loge(0.01)\n",
	"	// -d*d= -4.60517\n",
	"	// d=2.146\n",
	"	// If visibility=V, d=2.146 at fogZ=V -> fogDensity=2.146/V\n",
	"	{\n",
	"		MIDP  float d=fogDensity*abs(fogZ);\n",
	"		MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		LOWP  vec3  fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor.rgb=fogMix;\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPointSprite3DDrawingFragmentShader_nLine=107;
const char *YSGLSL_variColorPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      YSGLSL_POINTSPRITE_CLIPPING_NONE\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    YSGLSL_POINTSPRITE_CLIPPING_CIRCLE\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_MAX_NUM_TEXTURE    3\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform sampler2D textureIdent;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  LOWP  vec2 texCoordIn;\n",
	"attribute  MIDP  float pointSizeIn;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"varying  MIDP  vec2 texCoordOut;\n",
	"\n",
	"// Variables for fog\n",
	"uniform  MIDP  float fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4  fogColor;\n",
	"varying  HIGHP float fogZ;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform LOWP  float usePointSizeInPixel;\n",
	"uniform LOWP  float usePointSizeIn3D;\n",
	"uniform LOWP  float usePointClippingCircle;\n",
	"uniform LOWP  float useTexture;\n",
	"uniform LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void Ys_ProcessPointSprite()\n",
	"{\n",
	"	HIGHP vec4 prj1=projection*modelView*vec4(vertex,1.0);\n",
	"	HIGHP vec4 prj2=modelView*vec4(vertex,1.0);\n",
	"	prj2.y+=pointSizeIn;\n",
	"	prj2=projection*prj2;\n",
	"\n",
	"	HIGHP float pointSize3D=viewportHei*abs(prj2[1]/prj2[3]-prj1[1]/prj1[3])/2.0;\n",
	"\n",
	"	gl_PointSize=pointSizeIn*usePointSizeInPixel+pointSize3D*usePointSizeIn3D;\n",
	"}\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	texCoordOut=texCoordIn;\n",
	"	color=colorIn;\n",
	"\n",
	"	Ys_ProcessPointSprite();\n",
	"\n",
	"		fogZ=-vertexInView.z*fogEnabled;\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPointSprite3DDrawingVertexShader_nLine=113;
